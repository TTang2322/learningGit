def say_hello():
    print('Hello, World')

for i in range(5):
    say_hello()

# Your previous Plain Text content is preserved below:

# Welcome to Meta!

# This is just a simple shared plaintext pad, with no execution capabilities.

# When you know what language you would like to use for your interview,
# simply choose it from the dropdown in the top bar.

# Enjoy your interview!


"""
Find the number of all pairs in array of integer numbers whose sum is equal to a given number
     
         [25, 79, 15, 2], N = 40 =>  1

         [10, 10 , 20, 20, 30, 13], N = 30 => 4

         [10, 20], [10, 20], [10, 20], [10, 20]
"""
         def nb_pair(input_list, sum):
             
             input_list = input_list.sort() =>[10, 10 , 13, 20, 20, 30]

             nb_pair = 0
             for item in input_list: 

                 item_2 = sum - item

                #  if item_2 in input_list: 
                #      nb_pair += 1
                
                # binary search  O(log n)
                begin_boundary = 0
                end_boundary = len(input_list)

                while begin_boundary < end_boundary:
                    middle_index = (begin_boundary + end_boundary)/2
                    middle_item = input_list(middle_index)
                    if item_2 < middle_item:
                        end_boundary = middle_index

                    elif item_2 < middle_item:
                        begin_boundary = middle_index

                    else:
                        nb_pair += 1

            return nb_pair / 2

O(nlogn)



"""
2) Find Maximum Island Perimeter
    Find the largest perimeter of an island given a 2 dimensional array of 1's and 0's representing land and water respectively
   Perimeter = total # of lands on the edge of an island

1 0 1 1 1
1 0 1 1 1
0 1 0 1 1
max(2,1,7) = 7 
-> 7
"""

def get_lands(matrix,):


    def get_nb_neighbor():
        directions_list = [[0,1],[1,0],[0,-1],[-1,0]]
        nb_neighbor = 0
        for i, j 


    rows, cols = len(matrix), len(matrix[0])
    for d_i, d_j in directions_list:
        if 0 < i + d_i < rows and 0 <j+d_j <cols and grid[i+d_i][j+d_j] == 1:
            nb_neighbor += 1
        
    return nb_neighbor


    for i in range(rows):
        for j in range(clos):
            if matrix[i][i] == 1:
                neighbor = get_nb_neighbor(matrix, i, j)
                perimeter += 4 - neighbor

    perimeter = max(perimeter)
    return perimeter

